"""
Neste módulo implemente uma classe que represente o problema a ser resolvido.
esta classe deve ser capaz de avaliar a solução proposta e retornar uma recompensa para o agente.
A forma do cálculo da recompensa é livre, mas deve ser baseada na solução proposta.
"""
import ast
import subprocess
import sys

class Environment:
    def __init__(self, threshold_score=135, expected_output=None):
        self.threshold_score = threshold_score  # Minimum score to consider the code satisfactory
        self.expected_output = expected_output  # Expected output for code correctness check

    def calculate_reward(self, score, agent_type="coder"):
        """
        Calculates the reward for the coder or reviewer based on the score.
        :param score: Total score given by the Reviewer.
        :param agent_type: Type of agent ("coder" or "reviewer").
        :return: Reward (positive for high scores, negative for low scores).
        """
        try:
            if agent_type == "coder":
                if score >= self.threshold_score:
                    return 1.0  # Maximum reward for satisfactory code
                else:
                    return -1.0 + (score / self.threshold_score)  # Proportional penalty
            elif agent_type == "reviewer":
                return score / self.threshold_score  # Proportional reward for reviewer
        except Exception as e:
            print(f"Error calculating reward: {e}")
            return -1.0  # Default to maximum penalty on error

    def execute_code(self, code):
        """
        Executes the given code in a safe environment and captures any output or errors.
        :param code: Code to be executed.
        :return: Tuple of (success: bool, output: str).
        """
        try:
            # Run the code in a subprocess using the correct Python interpreter
            result = subprocess.run(
                [sys.executable, "-c", code],
                text=True,
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                return True, result.stdout.strip()  # Code ran successfully
            else:
                return False, result.stderr.strip()  # Code had an error
        except subprocess.TimeoutExpired:
            return False, "Error: Code execution timed out."
        except Exception as e:
            print(f"Error executing code: {e}")
            return False, str(e)

    def check_correctness(self, code_output):
        """
        Compares the code's output with the expected output to determine correctness.
        :param code_output: The output produced by executing the code.
        :return: Boolean indicating if the output matches the expected result.
        """
        return code_output == self.expected_output

    def analyze_code_quality(self, code):
        """
        Analyzes code quality using a simple static analysis.
        :param code: Code to be analyzed.
        :return: A score representing code quality.
        """
        issues = []
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    issues.append(f"Function '{node.name}' found.")
                elif isinstance(node, ast.Assign):
                    issues.append("Global variable assignment found.")
            if not issues:
                return 10  # Perfect score for no issues
            return max(0, 10 - len(issues))  # Deduct points based on issues found
        except SyntaxError:
            return 0  # Lowest quality score if there's a syntax error

    def calculate_complexity(self, code):
        """
        Calculates the complexity of the code based on certain heuristics.
        :param code: Code to be analyzed.
        :return: Complexity score (lower is simpler).
        """
        try:
            lines_of_code = len(code.splitlines())
            tree = ast.parse(code)
            function_count = sum(1 for node in ast.walk(tree) if isinstance(node, ast.FunctionDef))
            return lines_of_code + function_count * 2  # Basic complexity formula
        except Exception as e:
            print(f"Error calculating complexity: {e}")
            return float('inf')  # Infinite complexity on error

    def reward_coder(self, code, score):
        """
        Rewards the coder based on code quality, correctness, and complexity.
        :param code: The code generated by the coder.
        :param score: Score from the reviewer.
        :return: Reward score for the coder.
        """
        # Execute and check correctness
        success, output = self.execute_code(code)
        correctness_reward = 1.0 if success and self.check_correctness(output) else -1.0

        # Analyze code quality
        quality_score = self.analyze_code_quality(code)
        quality_reward = self.calculate_reward(quality_score, agent_type="coder")

        # Calculate complexity (penalize high complexity)
        complexity_score = self.calculate_complexity(code)
        complexity_penalty = -0.5 if complexity_score > 20 else 0.0

        # Combine all rewards/penalties
        return correctness_reward + quality_reward + complexity_penalty

    def reward_reviewer(self, previous_score, current_score):
        """
        Rewards the reviewer based on improvements in the analytic report's score.
        :param previous_score: The score from the last review.
        :param current_score: The score from the current review.
        :return: Reward score for the reviewer.
        """
        improvement = current_score - previous_score
        if improvement > 0:
            return self.calculate_reward(improvement, agent_type="reviewer")
        return -0.5  # Penalize if no improvement was made


